A module for generating Java-Swing applications just from placing annotations on its components. Read the full JavaDoc-Documentation [here Â»](https://proto4j.github.io/proto4j-swing/javadoc/index.html)

## First steps

This small chapter tries to show the basic usage of this library with a small example covering some key components. Let's consider the following scenario:

* the window should have the size 200*200
* the GUI should display a button with the text `click me!`
* by clicking this button a simple dialog should pop up

### 1. Class definition

At first, the class where all components are stored has to be created. A GUI generated by `proto4j-swing` may contain components annotated with `Swing` or `SwingWindow`, as well as `Nested`. Only fields with these annotations are covered while processing.

````java
@GUI
public class HelloWorldGUI {
    // element declarations would follow here
}
````

Next, the components have to be specified. Most likely these components are not final (but it is possible). The frame where the button will be added to could be defined as follows:

````java
// in class HelloWorldGUI
@SwingWindow
@Layout(BorderLayout.class)
@Bounds(size = {200, 200})
private JFrame mainFrame;
````

Although, it is not necessary to put a `SwingWindow` annotation on this field, there are more individual options provided by this annotation like `defaultCloseOperation` or `resizable`. With `Layout` the content-pane layout is set to the `Borderlayout` and the position specifies the size of this frame.

Now, the button has to be specified:
````java
@Swing(2) // see TIP below
@Option(text = "Click Me!", target = "mainFrame")
@Position(constraints = BorderLayout.CENTER)
private JButton button;
````
Here, the text and component this button should be added to is specified with the `Option` annotation. With `constraints = BorderLayout.CENTER` the button will be placed in the middle of the frame.

> TIP: The number given in the `Swing` annotation is *optional* and should be used if layout managers place their components in the order they were added to the parent component.

Before the GUI can be created an `EntryPoint` should be specified as follows (optional):
````java
@EntryPoint
public void showGui() {
    // You can use all fields as they will be initialized after
    // the generation process has finished.
    mainFrame.setVisible(true);    
}
````

> TIP: This method is designed to have optional arguments, so if parameters are defined, the corresponding arguments have to be provided when calling the start()-method of an `Entry`.

### 2. Listener creation

For now, we created the GUI without any action listeners. The frame and button would be visible but nothing happens if the button gets pressed. The `ActionListener` interface is used by the `JButton` to indicate whether it was pressed. This listener can be created in two ways:

1. Annotated class with implemented interface
    ````java
    // the default listener type is ActionListener.class, so the type
    // doesn't have to be specified.
    @ActionHandler({"button"}) 
    public class HelloWorldListener implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent e) {
            // JOptionPane.showMessageDialog(...)
        }
    }
    ````
   
2. Annotated method in a class
    ````java
    // the default listener type is ActionListener.class, so the type
    // doesn't have to be specified.
    @ActionHandler(value = {"button"}, type = ActionListener.class)
    public void myMethod(ActionEvent e) {
        // JOptionPane.showMessageDialog(...)
    }
    ````

### 3. Starting the GUI

At this point everything is ready to use:

````java
public static void main(String[]args){
    // create a basic entry
    Entry<HelloWorldGUI> entry = Entry.of(HelloWorldGUI.class);
    // add the action listener by adding it with the ActionHandler annotation
    entry.linkAction(new HelloWorldListener());
    // or add it directly
    entry.linkAction("button", ActionListener.class, new HelloWorldListener());
    entry.start();
}
````